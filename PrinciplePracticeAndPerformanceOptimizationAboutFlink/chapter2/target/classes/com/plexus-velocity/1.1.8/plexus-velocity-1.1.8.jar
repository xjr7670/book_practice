a);
  },

  handlePauseClick: function (evt) {
    var requestURL = contextURL + "/executor";
    var requestData = {"execid": execId, "ajax": "pauseFlow"};
    var successHandler = function (data) {
      console.log("pause clicked");
      if (data.error) {
        showDialog("Error", data.error);
      }
      else {
        showDialog("Paused", "Flow has been paused.");
        setTimeout(function () {
          updateStatus();
        }, 1100);
      }
    };
    ajaxCall(requestURL, requestData, successHandler);
  },

  handleResumeClick: function (evt) {
    var requestURL = contextURL + "/executor";
    var requestData = {"execid": execId, "ajax": "resumeFlow"};
    var successHandler = function (data) {
      console.log("pause clicked");
      if (data.error) {
        showDialog("Error", data.error);
      }
      else {
        showDialog("Resumed", "Flow has been resumed.");
        setTimeout(function () {
          updateStatus();
        }, 1100);
      }
    };
    ajaxCall(requestURL, requestData, successHandler);
  }
});

var showDialog = function (title, message) {
  $('#messageTitle').text(title);
  $('#messageBox').text(message);
  $('#messageDialog').modal();
}

var jobListView;
var mainSvgGraphView;

var flowLogView;
azkaban.FlowLogView = Backbone.View.extend({
  events: {
    "click #updateLogBtn": "handleUpdate"
  },
  initialize: function (settings) {
    this.model.set({"offset": 0});
    this.handleUpdate();
  },
  handleUpdate: function (evt) {
    var offset = this.model.get("offset");
    var requestURL = contextURL + "/executor";
    var model = this.model;
    console.log("fetchLogs offset is " + offset)

    $.ajax({
      async: false,
      url: requestURL,
      data: {
        "execid": execId,
        "ajax": "fetchExecFlowLogs",
        "offset": offset,
        "length": 50000
      },
      success: function (data) {
        console.log("fetchLogs");
        if (data.error) {
          console.log(data.error);
        }
        else {
          var log = $("#logSection").text();
          if (!log) {
            log = data.data;
          }
          else {
            log += data.data;
          }

          var newOffset = data.offset + data.length;

          $("#logSection").text(log);
          model.set({"offset": newOffset, "log": log});
          $(".logViewer").scrollTop(9999);
        }
      }
    });
  }
});

var statsView;
azkaban.StatsView = Backbone.View.extend({
  events: {},

  initialize: function (settings) {
    this.model.bind('change:graph', this.statusUpdate, this);
    this.model.bind('change:update', this.statusUpdate, this);
    this.model.bind('render', this.render, this);
    this.status = null;
    this.rendered = false;
  },

  statusUpdate: function (evt) {
    var data = this.model.get('data');
    this.status = data.status;
  },

  show: function () {
    this.model.trigger("render");
  },

  render: function (evt) {
    if (this.rendered == true) {
      return;
    }
    if (this.status != 'SUCCEEDED') {
      return;
    }
    flowStatsView.show(execId);
    this.rendered = true;
  }
});

var graphModel;

var logModel;
var flowTriggerModel;
azkaban.LogModel = Backbone.Model.extend({});

var updateStatus = function (updateTime) {
  var requestURL = contextURL + "/executor";
  var oldData = graphModel.get("data");
  var nodeMap = graphModel.get("nodeMap");

  if (!updateTime) {
    updateTime = oldData.updateTime ? oldData.updateTime : 0;
  }

  var requestData = {
    "execid": execId,
    "ajax": "fetchexecflowupdate",
    "lastUpdateTime": updateTime
  };

  var successHandler = function (data) {
    console.log("data updated");
    if (data.updateTime) {
      updateGraph(oldData, data);

      graphModel.set({"update": data});
      graphModel.trigger("change:update");
    }
  };
  ajaxCall(requestURL, requestData, successHandler);
}

function updatePastAttempts(data, update) {
  if (!update.pastAttempts) {
    return;
  }

  if (data.pastAttempts) {
    for (var i = 0; i < update.pastAttempts.length; ++i) {
      var updatedAttempt = update.pastAttempts[i];
      var found = false;
      for (var j = 0; j < data.pastAttempts.length; ++j) {
        var attempt = data.pastAttempts[j];
        if (attempt.attempt == updatedAttempt.attempt) {
          attempt.startTime = updatedAttempt.startTime;
          attempt.endTime = updatedAttempt.endTime;
          attempt.status = updatedAttempt.status;
          found = true;
          break;
        }
      }

      if (!found) {
        data.pastAttempts.push(updatedAttempt);
      }
    }
  }
  else {
    data.pastAttempts = update.pastAttempts;
  }
}

var updateGraph = function (data, update) {
  var nodeMap = data.nodeMap;
  data.startTime = update.startTime;
  data.endTime = update.endTime;
  data.updateTime = update.updateTime;
  data.status = update.status;

  updatePastAttempts(data, update);

  update.changedNode = data;

  if (update.nodes) {
    for (var i = 0; i < update.nodes.length; ++i) {
      var newNode = update.nodes[i];
      var oldNode = nodeMap[newNode.id];

      updateGraph(oldNode, newNode);
    }
  }
}

var updateTime = -1;
var updaterFunction = function () {
  var oldData = graphModel.get("data");
  var keepRunning =
      oldData.status != "SUCCEEDED" &&
      oldData.status != "FAILED" &&
      oldData.status != "KILLED";

  if (keepRunning) {
    updateStatus();

    var data = graphModel.get("data");
    if (data.status == "UNKNOWN" ||
        data.status == "WAITING" ||
        data.status == "PREPARING") {
      // 2 min updates
      setTimeout(function () {
        updaterFunction();
      }, 2 * 60 * 1000);
    }
    else if (data.status == "KILLING") {
      // 30 s updates - should finish soon now
      setTimeout(function () {
        updaterFunction();
      }, 30 * 1000);
    }
    else if (data.status != "SUCCEEDED" && data.status != "FAILED") {
      // 2 min updates
      setTimeout(function () {
        updaterFunction();
      }, 2 * 60 * 1000);
    }
    else {
      console.log("Flow finished, so no more updates");
      setTimeout(function () {
        updateStatus(0);
      }, 500);
    }
  }
  else {
    console.log("Flow finished, so no more updates");
  }
}

var logUpdaterFunction = function () {
  var oldData = graphModel.get("data");
  var keepRunning =
      oldData.status != "SUCCEEDED" &&
      oldData.status != "FAILED" &&
      oldData.status != "KILLED";
  if (keepRunning) {
    // update every 2 min for the logs until finished
    flowLogView.handleUpdate();
    setTimeout(function () {
      logUpdaterFunction();
    }, 2 * 60 * 1000);
  }
  else {
    flowLogView.handleUpdate();
  }
}

var exNodeClickCallback = function (event) {
  console.log("Node clicked callback");
  var jobId = event.currentTarget.jobid;
  var requestURL = contextURL + "/manager?project=" + projectName + "&flow="
      + flowId + "&job=" + jobId;
  var visualizerURL = contextURL + "/pigvisualizer?execid=" + execId + "&jobid="
      + jobId;

  var menu = [
    {
      title: "Open Job...", callback: function () {
      window.location.href = requestURL;
    }
    },
    {
      title: "Open Job in New Window...", callback: function () {
      window.open(requestURL);
    }
    },
    {
      title: "Visualize Job...", callback: function () {
      window.location.href = visualizerURL;
    }
    }
  ];

  contextMenuView.show(event, menu);
}

var exJobClickCallback = function (event) {
  console.log("Node clicked callback");
  var jobId = event.currentTarget.jobid;
  var requestURL = contextURL + "/manager?project=" + projectName + "&flow="
      + flowId + "&job=" + jobId;
  var visualizerURL = contextURL + "/pigvisualizer?execid=" + execId + "&jobid="
      + jobId;

  var menu = [
    {
      title: "Open Job...", callback: function () {
      window.location.href = requestU